The semantics of refine-eval is that it returns a (the?) minimal
abstract value that covers all the concrete values that there is
evidence to think could be returned from that exp-env.  I conjecture
that the only way it could return a smaller abstract value than it
returned before is if the exp is a compound application, and the
argument (or perhaps the closure) gets refined to a larger value,
which may cause the corresponding refine-apply to try to look the
answer up in the analysis and fail.  In this case, however, returning
the previous abstract value is fine, because if the application is
known to return values covered by X when it is known that it will be
given arguments covered by Y, then when we learn that its arguments
are acutally covered by something larger than Y, we still know that it
can very well return all of the things that justified X (and we may in
time learn that there are actually more).

I conjecture that this scenario can arise non-trivially only in the
presence of recursion, and then probably only if there is an IF in the
recursive cycle.  Why?  Well, to actually lose information,
refine-eval must have already returned some non-bottom value, which
means that the application must have had a non-bottom argument
(because the analysis we're doing is modeling a strict language); and
if it had a non-bottom argument that can still go up the lattice,
something recursive must have been going on.
