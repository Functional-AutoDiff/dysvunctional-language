;;; -*- scheme -*-

(define (car (cons x y)) x)
(define (cdr (cons x y)) y)

(define bundle-tag (gensym))
(define (make-bundle epsilon primal tangent)
  (list bundle-tag epsilon primal tangent))
(define (bundle? thing win lose)
  (if (and (pair? thing)
           (gensym? (car thing))
           (gensym= (car thing) bundle-tag))
      (win (bundle-epsilon thing)
           (bundle-primal thing)
           (bundle-tangent thing))
      (lose)))
(define (bundle-epsilon thing)
  (car (cdr thing)))
(define (bundle-primal thing)
  (car (cdr (cdr thing))))
(define (bundle-tangent thing)
  (car (cdr (cdr (cdr thing)))))
(define (forward? thing)
  (bundle? thing (lambda (x y z) #t) (lambda () #f)))

(define (primal epsilon thing)
  (bundle?
   thing
   (lambda (thing-eps thing-prim thing-tang)
     (if (gensym= thing-eps epsilon)
         thing-prim
         (make-bundle thing-eps
                      (primal epsilon thing-prim)
                      (primal epsilon thing-tang))))
   (lambda ()
     (cond ((real? thing)
            thing)
           ((procedure? thing)
            (lambda (x)
              (primal epsilon (thing x))))
           ((pair? thing)
            (cons (primal epsilon (car thing))
                  (primal epsilon (cdr thing))))
           (else thing)))))

(define (tangent epsilon thing)
  (bundle?
   thing
   (lambda (thing-eps thing-prim thing-tang)
     (if (gensym= thing-eps epsilon)
         thing-tang
         (make-bundle thing-eps
                      (tangent epsilon thing-prim)
                      (tangent epsilon thing-tang))))
   (lambda ()
     (cond ((real? thing)
            0)
           ((procedure? thing)
            (lambda (x)
              (tangent epsilon (thing x))))
           ((pair? thing)
            (cons (tangent epsilon (car thing))
                  (tangent epsilon (cdr thing))))
           (else thing)))))

(define (derivative f)
  (let ((epsilon (gensym)))
    (lambda (x)
      (tangent epsilon (f (make-bundle epsilon x (real 1)))))))

(define (derivative-f f)
  (derivative f))

(define (derivative-using-j* f)
  (derivative f))

(define (length l) (if (null? l) 0 (+ (length (cdr l)) 1)))

(define (map-n f n)
 (letrec ((loop (lambda (i) (if (= i n) '() (cons (f i) (loop (+ i 1)))))))
  (loop 0)))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x (real 0)) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex (real 1) i n))

(define (gradient-f f)
  (let ((epsilon (gensym)))
    (lambda (x)
      (let ((n (length x)))
        (map-n (lambda (i)
                 (tangent epsilon (f (make-bundle epsilon x (e i n)))))
               n)))))

(define (jacobian-using-j* f)
  (gradient-f f))

(define (perturb thing) thing)
(define (unperturb thing) thing)

(define (g:+ thing1 thing2)
  (bundle?
   thing1
   (lambda (eps prim tang)
     (make-bundle
      eps
      (g:+ prim (primal eps thing2))
      (g:+ tang (tangent eps thing2))))
   (lambda ()
     (bundle?
      thing2
      (lambda (eps prim tang)
        (make-bundle
         eps
         (g:+ (primal eps thing1) prim)
         (g:+ (tangent eps thing1) tang)))
      (lambda ()
        (+ thing1 thing2))))))

(define (g:* thing1 thing2)
  (bundle?
   thing1
   (lambda (eps prim tang)
     (let ((prim2 (primal eps thing2)))
       (make-bundle
        eps
        (g:* prim prim2)
        (g:+ (g:* tang prim2) (g:* prim (tangent eps thing2))))))
   (lambda ()
     (bundle?
      thing2
      (lambda (eps prim tang)
        (let ((prim1 (primal eps thing1)))
          (make-bundle
           eps
           (g:* prim1 prim)
           (g:+ (g:* (tangent eps thing1) prim) (g:* prim1 tang)))))
      (lambda ()
        (* thing1 thing2))))))
