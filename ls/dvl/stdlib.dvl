;;; -*- scheme -*-

(define (car (cons x y)) x)
(define (cdr (cons x y)) y)

(define bundle-tag (gensym))
(define (make-bundle epsilon primal tangent)
  (list bundle-tag epsilon primal tangent))
(define (bundle? thing win lose)
  (if (and (pair? thing)
           (gensym? (car thing))
           (gensym= (car thing) bundle-tag))
      (win (bundle-epsilon thing)
           (bundle-primal thing)
           (bundle-tangent thing))
      (lose)))
(define (bundle-epsilon thing)
  (car (cdr thing)))
(define (bundle-primal thing)
  (car (cdr (cdr thing))))
(define (bundle-tangent thing)
  (car (cdr (cdr (cdr thing)))))
(define (forward? thing)
  (bundle? thing (lambda (x y z) #t) (lambda () #f)))

(define (primal epsilon thing)
  (bundle?
   thing
   (lambda (thing-eps thing-prim thing-tang)
     (if (gensym= thing-eps epsilon)
         thing-prim
         (make-bundle thing-eps
                      (primal epsilon thing-prim)
                      (primal epsilon thing-tang))))
   (lambda ()
     (cond ((real? thing)
            thing)
           ((procedure? thing)
            (lambda (x)
              (primal epsilon (thing x))))
           ((pair? thing)
            (cons (primal epsilon (car thing))
                  (primal epsilon (cdr thing))))
           (else thing)))))

(define (tangent epsilon thing)
  (bundle?
   thing
   (lambda (thing-eps thing-prim thing-tang)
     (if (gensym= thing-eps epsilon)
         thing-tang
         (make-bundle thing-eps
                      (tangent epsilon thing-prim)
                      (tangent epsilon thing-tang))))
   (lambda ()
     (cond ((real? thing)
            0)
           ((procedure? thing)
            (lambda (x)
              (tangent epsilon (thing x))))
           ((pair? thing)
            (cons (tangent epsilon (car thing))
                  (tangent epsilon (cdr thing))))
           (else thing)))))

(define (derivative f)
  (let ((epsilon (gensym)))
    (lambda (x)
      (tangent epsilon (f (make-bundle epsilon x 1))))))

(define (derivative-f f)
  (derivative f))

(define (derivative-using-j* f)
  (derivative f))

(define (length l) (if (null? l) 0 (+ (length (cdr l)) 1)))

(define (map2 f l1 l2)
 (if (null? l1)
     '()
     (cons (f (car l1) (car l2)) (map2 f (cdr l1) (cdr l2)))))

(define (map-n f n)
 (letrec ((loop (lambda (i) (if (= i n) '() (cons (f i) (loop (+ i 1)))))))
  (loop 0)))

(define (v+ u v) (map2 g:+ u v))

(define (v- u v) (map2 g:- u v))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x (real 0)) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex (real 1) i n))

(define (gradient-f f)
  (lambda (x)
    (let ((n (length x)))
      (map-n (lambda (i)
               ((derivative (lambda (displacement)
                              (f (v+ x (ex displacement i n)))))
                0))
             n))))

(define (jacobian-using-j* f)
  (gradient-f f))

(define (perturb thing) thing)
(define (unperturb thing) thing)

(define (lift-real->real f df/dx)
  (define (self thing)
    (bundle?
     thing
     (lambda (eps prim tang)
       (make-bundle
        eps
        (self prim)
        (g:* (df/dx prim) tang)))
     (lambda () (f thing))))
  self)

(define (lift-real*real->real f df/dx1 df/dx2)
  (define (self thing1 thing2)
    (bundle?
     thing1
     (lambda (eps prim tang)
       (make-bundle
        eps
        (self prim (primal eps thing2))
        (g:+ (g:* (df/dx1 prim (primal eps thing2)) tang)
             (g:* (df/dx2 prim (primal eps thing2)) (tangent eps thing2)))))
     (lambda ()
       (bundle?
        thing2
        (lambda (eps prim tang)
          (make-bundle
           eps
           (self thing1 prim)
           (g:* (df/dx2 thing1 prim) tang)))
        (lambda ()
          (f thing1 thing2))))))
  self)

(define (primal* thing)
  (bundle? thing
   (lambda (eps prim tang)
     (primal* prim))
   (lambda () thing)))

(define (lift-real->boolean f)
  (lambda (thing)
    (f (primal* thing))))

(define (lift-real*real->boolean f)
  (lambda (thing1 thing2)
    (f (primal* thing1) (primal* thing2))))

(define (g:+ args) ((lift-real*real->real + (lambda (x1 x2) 1) (lambda (x1 x2) 1)) args))
(define (g:- args) ((lift-real*real->real - (lambda (x1 x2) 1) (lambda (x1 x2) -1)) args))
(define (g:* args) ((lift-real*real->real * (lambda (x1 x2) x2) (lambda (x1 x2) x1)) args))
(define (g:/ args)
  ((lift-real*real->real
    / (lambda (x1 x2) (g:/ 1 x2)) (lambda (x1 x2) (g:- 0 (g:/ x1 (g:* x2 x2))))) args))
(define (g:sqrt args) ((lift-real->real sqrt (lambda (x) (g:/ 1 (g:* 2 (g:sqrt x))))) args))
(define (g:exp args) ((lift-real->real exp (lambda (x) (g:exp x))) args))
(define (g:log args) ((lift-real->real log (lambda (x) (g:/ 1 x))) args))
(define (g:sin args) ((lift-real->real sin (lambda (x) (g:cos x))) args))
(define (g:cos args) ((lift-real->real cos (lambda (x) (g:- 0 (g:sin x)))) args))
(define (g:atan args) ((lift-real*real->real
                        atan
                        (lambda (x1 x2) (g:/ (g:- 0 x2) (g:+ (g:* x1 x1) (g:* x2 x2))))
                        (lambda (x1 x2) (g:/ x1 (g:+ (g:* x1 x1) (g:* x2 x2))))) args))
(define (g:= args) ((lift-real*real->boolean =) args))
(define (g:< args) ((lift-real*real->boolean <) args))
(define (g:> args) ((lift-real*real->boolean >) args))
(define (g:<= args) ((lift-real*real->boolean <=) args))
(define (g:>= args) ((lift-real*real->boolean >=) args))
(define (g:zero? args) ((lift-real->boolean zero?) args))
(define (g:positive? args) ((lift-real->boolean positive?) args))
(define (g:negative? args) ((lift-real->boolean negative?) args))
(define (g:real? args) ((lift-real->boolean real?) args))

(define (abs x)
  (if (g:negative? x)
      (g:- 0 x)
      x))
