;;; -*- scheme -*-

(define (car (cons x y)) x)
(define (cdr (cons x y)) y)

(define bundle-tag (gensym))
(define (make-bundle epsilon primal tangent)
  (list bundle-tag epsilon primal tangent))
(define (bundle? thing win lose)
  (if (and (pair? thing)
           (gensym? (car thing))
           (gensym= (car thing) bundle-tag))
      (win (bundle-epsilon thing)
           (bundle-primal thing)
           (bundle-tangent thing))
      (lose)))
(define (bundle-epsilon thing)
  (car (cdr thing)))
(define (bundle-primal thing)
  (car (cdr (cdr thing))))
(define (bundle-tangent thing)
  (car (cdr (cdr (cdr thing)))))
(define (forward? thing)
  (bundle? thing (lambda (x y z) #t) (lambda () #f)))

(define (primal epsilon thing)
  (bundle?
   thing
   (lambda (thing-eps thing-prim thing-tang)
     (if (gensym= thing-eps epsilon)
         thing-prim
         (make-bundle thing-eps
                      (primal epsilon thing-prim)
                      (primal epsilon thing-tang))))
   (lambda ()
     (cond ((real? thing)
            thing)
           ((procedure? thing)
            (lambda (x)
              (primal epsilon (thing x))))
           ((pair? thing)
            (cons (primal epsilon (car thing))
                  (primal epsilon (cdr thing))))
           (else thing)))))

(define (tangent epsilon thing)
  (bundle?
   thing
   (lambda (thing-eps thing-prim thing-tang)
     (if (gensym= thing-eps epsilon)
         thing-tang
         (make-bundle thing-eps
                      (tangent epsilon thing-prim)
                      (tangent epsilon thing-tang))))
   (lambda ()
     (cond ((real? thing)
            0)
           ((procedure? thing)
            ;; Note that this will have a different effect from the
            ;; bundle? case if thing intends to accept a procedural
            ;; argument and pass a closed-over bundle to it.  This
            ;; clause will have the effect of differentiating that
            ;; procedural argument, whereas taking the tangent of such
            ;; a bundle and passing it in to such a procedure will
            ;; not.  This is arguably correct.  See discussion in
            ;; church-encoding.tex.
            (hide-gensym-in-procedure epsilon
             (lambda (x)
               (tangent epsilon (thing x)))))
           ((pair? thing)
            (cons (tangent epsilon (car thing))
                  (tangent epsilon (cdr thing))))
           (else thing)))))

;;; This version should work.  Why?  The NEW-SYMBOL is made after I
;;; see the input, so the input cannot contain it.  This means that
;;; the input cannot tickle any instance of SYMBOL in PROCEDURE.  So
;;; far so good.  But is there any way for SYMBOL to escape PROCEDURE?
;;; If it tries, it will come out looking like NEW-SYMBOL, so I just
;;; re-hide that.

;;; Then again, maybe not.  What if X contains some procedure, and
;;; PROCEDURE calls it with several different closure arguments all of
;;; which are closed over SYMBOL?  Then the procedure in X will see
;;; several different closures with the same gensym in them, and that
;;; are no longer hiding anything, and may smash them into each other
;;; can cause chaos.  Would that even be wrong?  Arguably not.
;;; Consider that in the presence of standard definitions of addition,
;;; Chruch encoded pairs add differently from standard ones, because
;;; the Church encoding preserves any non-linearity in the
;;; continuation of the pair, whereas the standard addition does not.
;;; (lambda (cont) (cont x1 y1)) + (lambda (cont) (cont x2 y2)) =
;;; (lambda (cont) (+ (cont x1 y1) (cont x2 y2))) !=
;;; (lambda (cont) (cont (+ x1 x2) (+ y1 y2)))
;;; So perhaps the closures passed to X *should* share their
;;; perturbations.
(define (hide-gensym-in-procedure symbol procedure)
  (lambda (x)
    ;; Can I afford to bind the gensym outside the binder?  What
    ;; invariants would I need for that to work?  Do I even need to do
    ;; it for anything?
    (let* ((new-symbol (gensym))
           (answer ((swap-gensyms-in-object procedure symbol new-symbol) x)))
      (hide-gensym-in-object new-symbol answer))))

;;; I hope that the use pattern will be such that the symbol I am
;;; trying to hide only occurs inside closures, never exposed.
(define (hide-gensym-in-object symbol object)
  (cond ((procedure? object)
         (hide-gensym-in-procedure symbol object))
        ((pair? object)
         ;; Observe that if OBJECT contains functions, this clause
         ;; will do something different from what the previous clause
         ;; would have effected on a Church-encoded version of the
         ;; same OBJECT.  Why?  Because when the recursive calls
         ;; proceed to hide their procedures, they will make different
         ;; gensyms, and those procedures will not see each other's
         ;; perturbations; whereas if the continuation given to a
         ;; Church-encoded version were to recombine the procedures,
         ;; they *would* see each other's perturbations.  This is
         ;; arguably correct.  See the note in church-encoding.tex.
         (cons (hide-gensym-in-object symbol (car object))
               (hide-gensym-in-object symbol (cdr object))))
        ;; Can I rely on the object never *being* the symbol I am hiding?
        ;; What should I do if it is?
        ((and (gensym? object) (gensym= symbol object))
         (gensym))
        (else object)))

(define (swap-gensyms-in-object object symbol new-symbol)
  (cond ((procedure? object)
         (lambda (x)
           (let* ((new-x (swap-gensyms-in-object x symbol new-symbol))
                  (answer (object new-x)))
             (swap-gensyms-in-object answer symbol new-symbol))))
        ((gensym? object)
         (if (gensym= object symbol)
             new-symbol
             (if (gensym= object new-symbol)
                 symbol
                 object)))
        ((pair? object)
         (cons (swap-gensyms-in-object (car object) symbol new-symbol)
               (swap-gensyms-in-object (cdr object) symbol new-symbol)))
        (else object)))

(define (derivative f)
  (let ((epsilon (gensym)))
    (lambda (x)
      (tangent epsilon (f (make-bundle epsilon x 1))))))

(define (derivative-f f)
  (derivative f))

(define (derivative-using-j* f)
  (derivative f))

(define (length l) (if (null? l) 0 (+ (length (cdr l)) 1)))

(define (map2 f l1 l2)
 (if (null? l1)
     '()
     (cons (f (car l1) (car l2)) (map2 f (cdr l1) (cdr l2)))))

(define (map-n f n)
 (letrec ((loop (lambda (i) (if (= i n) '() (cons (f i) (loop (+ i 1)))))))
  (loop 0)))

(define (v+ u v) (map2 g:+ u v))

(define (v- u v) (map2 g:- u v))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x (real 0)) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex (real 1) i n))

(define (gradient-f f)
  (lambda (x)
    (let ((n (length x)))
      (map-n (lambda (i)
               ((derivative (lambda (displacement)
                              (f (v+ x (ex displacement i n)))))
                0))
             n))))

(define (jacobian-using-j* f)
  (gradient-f f))

(define (perturb thing) thing)
(define (unperturb thing) thing)

(define (lift-real->real f df/dx)
  (define (self thing)
    (bundle?
     thing
     (lambda (eps prim tang)
       (make-bundle
        eps
        (self prim)
        (g:* (df/dx prim) tang)))
     (lambda () (f thing))))
  self)

(define (lift-real*real->real f df/dx1 df/dx2)
  (define (self thing1 thing2)
    (bundle?
     thing1
     (lambda (eps prim tang)
       (make-bundle
        eps
        (self prim (primal eps thing2))
        (g:+ (g:* (df/dx1 prim (primal eps thing2)) tang)
             (g:* (df/dx2 prim (primal eps thing2)) (tangent eps thing2)))))
     (lambda ()
       (bundle?
        thing2
        (lambda (eps prim tang)
          (make-bundle
           eps
           (self thing1 prim)
           (g:* (df/dx2 thing1 prim) tang)))
        (lambda ()
          (f thing1 thing2))))))
  self)

(define (primal* thing)
  (bundle? thing
   (lambda (eps prim tang)
     (primal* prim))
   (lambda () thing)))

(define (lift-real->boolean f)
  (lambda (thing)
    (f (primal* thing))))

(define (lift-real*real->boolean f)
  (lambda (thing1 thing2)
    (f (primal* thing1) (primal* thing2))))

(define (g:+ args) ((lift-real*real->real + (lambda (x1 x2) 1) (lambda (x1 x2) 1)) args))
(define (g:- args) ((lift-real*real->real - (lambda (x1 x2) 1) (lambda (x1 x2) -1)) args))
(define (g:* args) ((lift-real*real->real * (lambda (x1 x2) x2) (lambda (x1 x2) x1)) args))
(define (g:/ args)
  ((lift-real*real->real
    / (lambda (x1 x2) (g:/ 1 x2)) (lambda (x1 x2) (g:- 0 (g:/ x1 (g:* x2 x2))))) args))
(define (g:sqrt args) ((lift-real->real sqrt (lambda (x) (g:/ 1 (g:* 2 (g:sqrt x))))) args))
(define (g:exp args) ((lift-real->real exp (lambda (x) (g:exp x))) args))
(define (g:log args) ((lift-real->real log (lambda (x) (g:/ 1 x))) args))
(define (g:sin args) ((lift-real->real sin (lambda (x) (g:cos x))) args))
(define (g:cos args) ((lift-real->real cos (lambda (x) (g:- 0 (g:sin x)))) args))
(define (g:atan args) ((lift-real*real->real
                        atan
                        (lambda (x1 x2) (g:/ (g:- 0 x2) (g:+ (g:* x1 x1) (g:* x2 x2))))
                        (lambda (x1 x2) (g:/ x1 (g:+ (g:* x1 x1) (g:* x2 x2))))) args))
(define (g:= args) ((lift-real*real->boolean =) args))
(define (g:< args) ((lift-real*real->boolean <) args))
(define (g:> args) ((lift-real*real->boolean >) args))
(define (g:<= args) ((lift-real*real->boolean <=) args))
(define (g:>= args) ((lift-real*real->boolean >=) args))
(define (g:zero? args) ((lift-real->boolean zero?) args))
(define (g:positive? args) ((lift-real->boolean positive?) args))
(define (g:negative? args) ((lift-real->boolean negative?) args))
(define (g:real? args) ((lift-real->boolean real?) args))

(define (abs x)
  (if (g:negative? x)
      (g:- 0 x)
      x))
