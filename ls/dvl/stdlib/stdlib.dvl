;;; -*- scheme -*-

(define (car (cons x y)) x)
(define (cdr (cons x y)) y)
(define (not x) (if x #f #t))
(define (append l1 l2)
  (if (pair? l1)
      (cons (car l1) (append (cdr l1) l2))
      l2))

(define least-gensym (gensym))
(define (gensym-max g1 g2)
  (if (gensym< g1 g2) g2 g1))

(define bundle-tag (gensym))
(define (make-bundle epsilon primal tangent)
  (list bundle-tag epsilon primal tangent))
(define (bundle? thing win lose)
  (if (and (pair? thing)
           (gensym? (car thing))
           (gensym= (car thing) bundle-tag))
      (win (bundle-epsilon thing)
           (bundle-primal thing)
           (bundle-tangent thing))
      (lose)))
(define (bundle-epsilon thing)
  (car (cdr thing)))
(define (bundle-primal thing)
  (car (cdr (cdr thing))))
(define (bundle-tangent thing)
  (car (cdr (cdr (cdr thing)))))
(define (forward? thing)
  (bundle? thing (lambda (x y z) #t) (lambda () #f)))
(define (%make-bundle epsilon thing1 thing2)
  ;; Expect bundles to be interleaved inside pairs and procedures, but
  ;; force nesting of bundles and tape cells to respect the creation
  ;; order of perturbations.
  (define (operate-forward eps)
    (let ((prim1 (primal eps thing1))
          (prim2 (primal eps thing2))
          (tang1 (tangent eps thing1))
          (tang2 (tangent eps thing2)))
      (make-bundle
       eps
       (make-bundle epsilon prim1 prim2)
       (make-bundle epsilon tang1 tang2))))
  (let ((top-eps (gensym-max (perturbation-of thing1)
                             (perturbation-of thing2))))
    (if (gensym< top-eps epsilon)
        (%make-bundle epsilon thing1 thing2)
        (operate-forward top-eps))))

(define (perturbation-of thing)
  (bundle?
   thing
   (lambda (eps prim tang)
     eps)
   (lambda ()
     (tape-cell?
      thing
      (lambda (eps id prim partials)
        eps)
      (lambda ()
        least-gensym)))))

(define tape-cell-tag (gensym))
(define (make-tape-cell epsilon id primal partial-alist)
  (list tape-cell-tag epsilon id primal partial-alist))
(define (tape-cell? thing win lose)
  (if (and (pair? thing)
           (gensym? (car thing))
           (gensym= (car thing) tape-cell-tag))
      (win (tape-cell-epsilon thing)
           (tape-cell-id thing)
           (tape-cell-primal thing)
           (tape-cell-partials thing))
      (lose)))
(define (tape-cell-epsilon thing)
  (car (cdr thing)))
(define (tape-cell-id thing)
  (car (cdr (cdr thing))))
(define (tape-cell-primal thing)
  (car (cdr (cdr (cdr thing)))))
(define (tape-cell-partials thing)
  (car (cdr (cdr (cdr (cdr thing))))))
(define (reverse? thing)
  (tape-cell? thing (lambda (x y z w) #t) (lambda () #f)))

(define (new-tape-cell epsilon primal partial-alist)
  (make-tape-cell epsilon (gensym) primal partial-alist))

(define (primal epsilon thing)
  (bundle?
   thing
   (lambda (thing-eps thing-prim thing-tang)
     (if (gensym= thing-eps epsilon)
         thing-prim
         (make-bundle thing-eps
                      (primal epsilon thing-prim)
                      (primal epsilon thing-tang))))
   (lambda ()
     (cond ((real? thing)
            thing)
           ((reverse? thing)
            ;; TODO This expects that primal is always called with the
            ;; outermost available epsilon, and that bundles and tape
            ;; cells are properly nested.
            thing)
           ((procedure? thing)
            (lambda (x)
              (primal epsilon (thing x))))
           ((pair? thing)
            (cons (primal epsilon (car thing))
                  (primal epsilon (cdr thing))))
           (else thing)))))

(define (tangent epsilon thing)
  (bundle?
   thing
   (lambda (thing-eps thing-prim thing-tang)
     (if (gensym= thing-eps epsilon)
         thing-tang
         (make-bundle thing-eps
                      (tangent epsilon thing-prim)
                      (tangent epsilon thing-tang))))
   (lambda ()
     (cond ((real? thing)
            0)
           ((reverse? thing)
            ;; TODO This expects that tangent is always called with
            ;; the outermost available epsilon, and that bundles and
            ;; tape cells are properly nested.
            0)
           ((procedure? thing)
            ;; Note that this will have a different effect from the
            ;; bundle? case if thing intends to accept a procedural
            ;; argument and pass a closed-over bundle to it.  This
            ;; clause will have the effect of differentiating that
            ;; procedural argument, whereas taking the tangent of such
            ;; a bundle and passing it in to such a procedure will
            ;; not.  This is arguably correct.  See discussion in
            ;; church-encoding.tex.
            (hide-gensym-in-procedure epsilon
             (lambda (x)
               (tangent epsilon (thing x)))))
           ((pair? thing)
            (cons (tangent epsilon (car thing))
                  (tangent epsilon (cdr thing))))
           (else thing)))))

;;; This version should work.  Why?  The NEW-SYMBOL is made after I
;;; see the input, so the input cannot contain it.  This means that
;;; the input cannot tickle any instance of SYMBOL in PROCEDURE.  So
;;; far so good.  But is there any way for SYMBOL to escape PROCEDURE?
;;; If it tries, it will come out looking like NEW-SYMBOL, so I just
;;; re-hide that.

;;; Then again, maybe not.  What if X contains some procedure, and
;;; PROCEDURE calls it with several different closure arguments all of
;;; which are closed over SYMBOL?  Then the procedure in X will see
;;; several different closures with the same gensym in them, and that
;;; are no longer hiding anything, and may smash them into each other
;;; can cause chaos.  Would that even be wrong?  Arguably not.
;;; Consider that in the presence of standard definitions of addition,
;;; Chruch encoded pairs add differently from standard ones, because
;;; the Church encoding preserves any non-linearity in the
;;; continuation of the pair, whereas the standard addition does not.
;;; (lambda (cont) (cont x1 y1)) + (lambda (cont) (cont x2 y2)) =
;;; (lambda (cont) (+ (cont x1 y1) (cont x2 y2))) !=
;;; (lambda (cont) (cont (+ x1 x2) (+ y1 y2)))
;;; So perhaps the closures passed to X *should* share their
;;; perturbations.
(define (hide-gensym-in-procedure symbol procedure)
  (lambda (x)
    ;; Can I afford to bind the gensym outside the binder?  What
    ;; invariants would I need for that to work?  Do I even need to do
    ;; it for anything?
    (let* ((new-symbol (gensym))
           (answer ((swap-gensyms-in-object procedure symbol new-symbol) x)))
      (hide-gensym-in-object new-symbol answer))))

;;; I hope that the use pattern will be such that the symbol I am
;;; trying to hide only occurs inside closures, never exposed.
(define (hide-gensym-in-object symbol object)
  (cond ((procedure? object)
         (hide-gensym-in-procedure symbol object))
        ((pair? object)
         ;; Observe that if OBJECT contains functions, this clause
         ;; will do something different from what the previous clause
         ;; would have effected on a Church-encoded version of the
         ;; same OBJECT.  Why?  Because when the recursive calls
         ;; proceed to hide their procedures, they will make different
         ;; gensyms, and those procedures will not see each other's
         ;; perturbations; whereas if the continuation given to a
         ;; Church-encoded version were to recombine the procedures,
         ;; they *would* see each other's perturbations.  This is
         ;; arguably correct.  See the note in church-encoding.tex.
         (cons (hide-gensym-in-object symbol (car object))
               (hide-gensym-in-object symbol (cdr object))))
        ;; Can I rely on the object never *being* the symbol I am hiding?
        ;; What should I do if it is?
        ((and (gensym? object) (gensym= symbol object))
         (gensym))
        (else object)))

(define (swap-gensyms-in-object object symbol new-symbol)
  (cond ((procedure? object)
         (lambda (x)
           (let* ((new-x (swap-gensyms-in-object x symbol new-symbol))
                  (answer (object new-x)))
             (swap-gensyms-in-object answer symbol new-symbol))))
        ((gensym? object)
         (if (gensym= object symbol)
             new-symbol
             (if (gensym= object new-symbol)
                 symbol
                 object)))
        ((pair? object)
         (cons (swap-gensyms-in-object (car object) symbol new-symbol)
               (swap-gensyms-in-object (cdr object) symbol new-symbol)))
        (else object)))

(define (derivative f)
  (let ((epsilon (gensym)))
    (lambda (x)
      (tangent epsilon (f (make-bundle epsilon x 1))))))

(define (derivative-f f)
  (derivative f))

(define (derivative-using-j* f)
  (derivative f))

(define (length l) (if (null? l) 0 (+ (length (cdr l)) 1)))

(define (reverse l)
  (let loop ((l l)
             (answer '()))
    (if (null? l)
        answer
        (loop (cdr l) (cons (car l) answer)))))

(define (map f l) (if (null? l) '() (cons (f (car l)) (map f (cdr l)))))

(define (map2 f l1 l2)
 (if (null? l1)
     '()
     (cons (f (car l1) (car l2)) (map2 f (cdr l1) (cdr l2)))))

(define (map-n f n)
 (letrec ((loop (lambda (i) (if (= i n) '() (cons (f i) (loop (+ i 1)))))))
  (loop 0)))

(define (v+ u v) (map2 g:+ u v))

(define (v- u v) (map2 g:- u v))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x (real 0)) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex (real 1) i n))

(define (gradient-f f)
  (lambda (x)
    (let ((n (length x)))
      (map-n (lambda (i)
               ((derivative (lambda (displacement)
                              (f (v+ x (ex displacement i n)))))
                0))
             n))))

(define (jacobian-using-j* f)
  (gradient-f f))

(define (perturb thing) thing)
(define (unperturb thing) thing)

(define (lift-real->real f df/dx)
  (define (self thing)
    (bundle?
     thing
     (lambda (eps prim tang)
       (make-bundle
        eps
        (self prim)
        (g:* (df/dx prim) tang)))
     (lambda ()
       (tape-cell?
        thing
        (lambda (eps id prim partials)
          (new-tape-cell
           eps
           (self prim)
           (list (cons thing (df/dx prim)))))
        (lambda () (f thing))))))
  self)

(define (lift-real*real->real f df/dx1 df/dx2)
  (define (self thing1 thing2)
    (define (reverse-primal epsilon thing)
      ;; This assumes that epsilon is greater than or equal to the
      ;; perturbation of thing, and is an epsilon associated with
      ;; reverse mode.
      (if (and (reverse? thing)
               (gensym= epsilon (tape-cell-epsilon thing)))
          (tape-cell-primal thing)
          thing))
    (define (operate-forward eps)
      (let ((prim1 (primal eps thing1))
            (prim2 (primal eps thing2))
            (tang1 (tangent eps thing1))
            (tang2 (tangent eps thing2)))
        (make-bundle
         eps
         (self prim1 prim2)
         (g:+ (g:* (df/dx1 prim1 prim2) tang1)
              (g:* (df/dx2 prim1 prim2) tang2)))))
    (define (operate-reverse eps)
      (let ((prim1 (reverse-primal eps thing1))
            (prim2 (reverse-primal eps thing2)))
        (let ((partial1
               (if (and (reverse? thing1)
                        (gensym= eps (tape-cell-epsilon thing1)))
                   (list
                    (cons thing1 (df/dx1 prim1 prim2)))
                   '()))
              (partial2
               (if (and (reverse? thing2)
                        (gensym= eps (tape-cell-epsilon thing2)))
                   (list
                    (cons thing2 (df/dx2 prim1 prim2)))
                   '())))
          (new-tape-cell
           eps
           (self prim1 prim2)
           (append partial1 partial2)))))
    (let ((eps1 (perturbation-of thing1))
          (eps2 (perturbation-of thing2)))
      (cond ((and (forward? thing1) (not (gensym< eps1 eps2)))
             (operate-forward eps1))
            ((and (reverse? thing1) (not (gensym< eps1 eps2)))
             (operate-reverse eps1))
            ((and (forward? thing2) (gensym< eps1 eps2))
             (operate-forward eps2))
            ((and (reverse? thing2) (gensym< eps1 eps2))
             (operate-reverse eps2))
            (else (f thing1 thing2)))))
  self)

(define (primal* thing)
  (bundle? thing
   (lambda (eps prim tang)
     (primal* prim))
   (lambda ()
     (tape-cell? thing
      (lambda (eps id prim partials)
        (primal* prim))
      (lambda () thing)))))

(define (lift-real->boolean f)
  (lambda (thing)
    (f (primal* thing))))

(define (lift-real*real->boolean f)
  (lambda (thing1 thing2)
    (f (primal* thing1) (primal* thing2))))

(define (g:+ args) ((lift-real*real->real v:+ (lambda (x1 x2) 1) (lambda (x1 x2) 1)) args))
(define (g:- args) ((lift-real*real->real v:- (lambda (x1 x2) 1) (lambda (x1 x2) -1)) args))
(define (g:* args) ((lift-real*real->real v:* (lambda (x1 x2) x2) (lambda (x1 x2) x1)) args))
(define (g:/ args)
  ((lift-real*real->real
    v:/ (lambda (x1 x2) (g:/ 1 x2)) (lambda (x1 x2) (g:- 0 (g:/ x1 (g:* x2 x2))))) args))
(define (g:sqrt args) ((lift-real->real sqrt (lambda (x) (g:/ 1 (g:* 2 (g:sqrt x))))) args))
(define (g:exp args) ((lift-real->real exp (lambda (x) (g:exp x))) args))
(define (g:log args) ((lift-real->real log (lambda (x) (g:/ 1 x))) args))
(define (g:sin args) ((lift-real->real sin (lambda (x) (g:cos x))) args))
(define (g:cos args) ((lift-real->real cos (lambda (x) (g:- 0 (g:sin x)))) args))
(define (g:atan args) ((lift-real*real->real
                        atan
                        (lambda (x1 x2) (g:/ (g:- 0 x2) (g:+ (g:* x1 x1) (g:* x2 x2))))
                        (lambda (x1 x2) (g:/ x1 (g:+ (g:* x1 x1) (g:* x2 x2))))) args))
(define (g:= args) ((lift-real*real->boolean =) args))
(define (g:< args) ((lift-real*real->boolean <) args))
(define (g:> args) ((lift-real*real->boolean >) args))
(define (g:<= args) ((lift-real*real->boolean <=) args))
(define (g:>= args) ((lift-real*real->boolean >=) args))
(define (g:zero? args) ((lift-real->boolean zero?) args))
(define (g:positive? args) ((lift-real->boolean positive?) args))
(define (g:negative? args) ((lift-real->boolean negative?) args))
(define (g:real? args) ((lift-real->boolean real?) args))

(define (abs x)
  (if (g:negative? x)
      (g:- 0 x)
      x))

(define (pointwise f obj)
  (cond ((real? obj)
         (f obj))
        ((pair? obj)
         (cons (f (car obj)) (f (cdr obj))))
        ((procedure? obj)
         (lambda (x) (f (obj x))))
        (else
         obj)))

(define (equal? x y)
 (or
  (and (null? x) (null? y))
  (and (boolean? x) (boolean? y) (or (and x y) (and (not x) (not y))))
  (and (real? x) (real? y) (= x y))
  (and (pair? x) (pair? y) (equal? (car x) (car y)) (equal? (cdr x) (cdr y)))
  (and (gensym? x) (gensym? y) (gensym= x y))))

(define (pointwise2 f obj1 obj2)
  (cond ((and (real? obj1) (real? obj2))
         (f obj1 obj2))
        ((and (pair? obj1) (pair? obj2))
         (cons (f (car obj1) (car obj2))
               (f (cdr obj1) (cdr obj2))))
        ((and (procedure? obj1) (procedure? obj2))
         (lambda (z)
           (f (obj1 z) (obj2 z))))
        ((equal? obj1 obj2)
         obj1)
        (else (error)) ; TODO Error string "Object shape mismatch"
        ))

(define (v:+ x y)
  (cond ((universal-zero? x) y)
        ((universal-zero? y) x)
        ((and (real? x) (real? y))
         (+ x y))
        (else
         (pointwise2 g:+ x y))))

(define (v:- x y)
  (v:+ x (g:* -1 y)))

(define (v:* obj1 obj2)
  (if (real? obj1)
      (if (real? obj2)
          (* obj1 obj2)
          (pointwise (lambda (x) (g:* obj1 x)) obj2))
      (if (real? obj2)
          (pointwise (lambda (x) (g:* x obj2)) obj1)
          (error)) ; TODO Error string "Multiplication mismatch"
      ))

(define (v:/ obj1 obj2)
  (if (real? obj2)
      (if (real? obj1)
          (/ obj1 obj2)
          (pointwise (lambda (x) (g:/ x obj2)) obj1))
      (error) ; TODO Error string "Dividing by a non-real"
      ))

(define zero (gensym))

(define (universal-zero? thing)
  (and (gensym? thing)
       (gensym= thing zero)))

(define ((reduce f i) l)
  (if (null? l) i (f (car l) ((reduce f i) (cdr l)))))

(define sum (reduce g:+ zero))
(define product (reduce g:* 1))

(define (gradient-r f x)
  (let ((eps (gensym)))
    (define (tapify thing)
      (cond ((or (real? thing) (forward? thing) (reverse? thing))
             (new-tape-cell eps thing '()))
            ((pair? thing)
             (cons (tapify (car thing))
                   (tapify (cdr thing))))
            ((procedure? thing)
             ;; TODO Cannot tapify procedures
             (error))
            (else
             thing)))
    (let* ((inputs (tapify x))
           (forward-phase-answer (f inputs))
           ;; No perturbation greater than eps should be observable in
           ;; forward-phase-answer.
           (sensitivities
            (tape-cell?
             forward-phase-answer
             (lambda (answer-eps id prim partials)
               (if (gensym= eps answer-eps)
                   (let* (((cons seen sorted) (compute-visiting-order forward-phase-answer '() '())))
                     (reverse-phase sorted (list (cons id 1))))
                   ;; f is not infinitesimally dependent on x, return
                   ;; the empty sensitivity list.
                   '()))
             (lambda ()
               ;; f is not infinitesimally dependent on x, return the
               ;; empty sensitivity list.
               '()))))
      (define (interpret thing)
        (cond ((or (real? thing) (forward? thing)
                   (and (reverse? thing) (not (gensym= eps (tape-cell-epsilon thing)))))
               0)
              ((and (reverse? thing) (gensym= eps (tape-cell-epsilon thing)))
               (assq (tape-cell-id thing) sensitivities))
              ((pair? thing)
               (cons (interpret (car thing)) 
                     (interpret (cdr thing))))
              ((procedure? thing)
               (error))
              (else thing)))
      (interpret inputs))))

(define (compute-visiting-order node seen sorted)
  (if (memq (tape-cell-id node) seen)
      (cons seen sorted)
      (let (((cons seen sorted)
             (compute-visiting-order*
              (map car (tape-cell-partials node))
              (cons (tape-cell-id node) seen)
              sorted)))
        (cons seen (cons node sorted)))))

(define (compute-visiting-order* nodes seen sorted)
  (if (null? nodes)
      (cons seen sorted)
      (let (((cons seen sorted)
             (compute-visiting-order (car nodes) seen sorted)))
        (compute-visiting-order* (cdr nodes) seen sorted))))

(define (reverse-phase nodes sensitivities)
  (if (null? nodes)
      sensitivities
      ;; Since you're going in topological sort order, when you reach
      ;; a node you know you are done updating its sensitivity.
      (let ((sensitivity (assq (tape-cell-id (car nodes)) sensitivities)))
        (let loop ((sensitivities sensitivities)
                   (partials (tape-cell-partials (car nodes))))
          (if (null? partials)
              (reverse-phase (cdr nodes) sensitivities)
              (let (((cons (cons partial-cell partial-factor) other-partials) partials))
                (loop
                 (updateq-with
                  sensitivities
                  (tape-cell-id partial-cell)
                  (g:* partial-factor sensitivity)
                  g:+)
                 other-partials)))))))

(define (memq gensym lst)
  (if (null? lst)
      #f
      (if (gensym= gensym (car lst))
          #t
          (memq gensym (cdr lst)))))

(define (assq item alist)
  (if (null? alist)
      0
      (let (((cons (cons key datum) rest) alist))
        (if (gensym= item key)
            datum
            (assq item rest)))))

(define (updateq-with alist key datum merge)
  (if (null? alist)
      (list (cons key datum))
      (let (((cons (cons a-key a-datum) rest) alist))
        (if (gensym= key a-key)
            (cons (cons a-key (merge datum a-datum))
                  rest)
            (cons (cons a-key a-datum)
                  (updateq-with (cdr alist) key datum merge))))))
