Desiderata:
- Semantic match (e.g., garbage collected)
  - Makes it easy to generate for
- Mature, robust, supported, Free
- Profilable
- Useful facilities for e.g., plotting
- Good FFI
  - It's pretty easy to get FOL to interoperate with its host backend,
    but a good FFI beyond that would be good too.
- High quality output
  - unboxed floating point
  - take advantage of large basic blocks?
  - portable to further platforms?

Candidates:
- Scheme (RkRS)
- Specific Scheme
  - MIT Scheme, Stalin, Racket, Gambit, Chicken, Ikarus, Bigloo?
- Common Lisp (the standard)
- Specific Common Lisp
  - SBCL, Allegro, etc
- ML (SML/NJ, MLton, the standard)
- Haskell (Core?)
- Java (the language, or the bytecodes, or Scala, or Clojure...)
  - The gcc implemetation of Java might be both garbage collected and
    have good treatment of floats.
- C, or C--, or LLVM
- Fortran
  - Gerry says it has actually gotten quite nice over the years
- Others? .NET?


On MIT Scheme unboxing floats, Taylor says
> LIAR does not unbox variables.  The best you can do is
>
> (let ((x (flo:+ y z)))
>  (declare (integrate x))   ;***
>  (let ((y (flo:* x x)))
>    ...))
>
> and hope the RTL CSE takes care of the code duplication (which it
> usually does, although it may not be happy about exponential explosion
> of code if you do this for a lot of variables in a big procedure).
