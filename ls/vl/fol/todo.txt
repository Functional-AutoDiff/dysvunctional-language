Expository explanations
- Push TIDY into its own file?
- Explain the rule system
- Sweep TODOs
- Actually explain SRA
- Update explanation of VL (and DVL?) to reflect FOL's separate
  identity
- Make FOL executable standalone, releasable, workbookable
- Do I want to make all the analysis stages treat the entry point
  as yet another definition?
- General destructurer of definitions, instead of all these rules?

NB: SRA can remove call graph edges by eliminating contentless
  expressions that contain calls to procedures.  However, all
  procedures are contentful, because otherwise the code generator
  would not have emitted them.  Does the code generator emit
  expressions that request some content and then throw it away?  In
  any case, there are FOL programs where SRA exposes work for
  inlining; should I explain this?  Should I explain that VL and DVL
  do not emit such programs?

NB: The reason that some of my recursions are broken into expression
  loops and a toplevel crunch is that the top level is the only
  place that introduces bindings with letrec scope.

NB: From the compiler writer's perspective, FOL is a funny
  representation for a dataflow graph: a list of trees of
  single-predecessor nodes.  This facilitates writing dataflow and
  optimization passes that cascade over said single-predecessor nodes.
  With the important difference that the stack, the heap, and
  procedure returns are implicit.  In particular, knoweldge of returns
  gives me flow information that Appel-style data flow analyses don't
  have: which node will be the target of a return-jump, given
  the node that was the source of the call-jump.

NB: INTERPROCEDURAL-DEAD-CODE-ELIMINATION is solving the following
  liveness equations: TODO

----------------------------------------------------------------------

Compilation with MIT Scheme
- Interprocedural must-alias analysis?
  - Can this collapse identical perturbations and recover tower mode on
    (D (D (lambda (x) ...)))?
  - Can this collapse primals and recover stack tangent mode?
- Solved gensyms?  Is this actually possible?

The next step both for good output and fast compilation is:

Try to break gensym handling
- Try to make solved gensyms actually solved
  - Good output on dvl-sqrt-5
  - Fast enough to put dvl-sqrt-5 into the test suite?

Write inlining of used-once bindings (post-SRA); undoes ANF
- This is the intraprocedural analog of inlining procedures (I think)


Sussman's example of where differentiating functions that output
functions is useful:

(define (((delta eta) f) q)
  (let ((g (lambda (eps) (f (+ q (* eps eta))))))
    ((D g) 0)))

; Nonsense useage example:
((((delta cos) D) square) 3)

A good testing strategy is to differentiate (lambda (x) (/ (f x) (f
x))) for some suitably horrible f many times.

Generate syntax checkers from the grammars?  Generate random example
programs from the grammars?

Software-validate the following assertions:
- all optimizer stages preserve uniqueness of names
- all optimizer stages preserve the semantics of any valid FOL program
  (with alpha renaming inserted where needed)
  - what is the exact list of criteria for "valid"?
    - can I effectively check those with the type checker?
      - can I efficiently generate random valid programs?
- de-aliasing, dead code elimination, and tidying are idempotent
- de-aliasing does not generate work for inlining and SRA
- dead variable elimination does not generate work for SRA or de-aliasing

Rename vector to closure, to distinguish it from (variable-length)
arrays (that may be accessed at computed indecies).

(begin
 (define (foo x y)
   (argument-types real real real)
   (+ x y))
 (let ((foo 3))
   (foo 1 2)))
breaks horribly on inlining (global vs local name clash)

INLINE breaks alpha renaming by duplicating code bodies.

SRA depends on alpha renaming because it deparallelizes LET-VALUES (in
its post-processor).

de-aliasing depends on alpha renaming when checking whether a variable
is aliased to something in scope at its binding site (this may be
fixable).

TIDY depends on alpha renaming because it lifts LETs.
