* Alpha renaming

The purpose of alpha renaming is to ensure that every variable has at
most one binding cite.  A variable needs renaming at its binding cite
if it is known to be bound at some other cite.  Other variables must
be renamed to what they were renamed to at their immediate binding
cites.  Hence the following algorithm:

- Traverse the expression recursively carrying around an environment
  =E= mapping variables in the scope to new names and a set =B= of
  variables that are known to be bound somewhere.

- Every instance of =Var m= is renamed to =Var n=, where =n= is the
  new name =m= is bound to in the environment =E=.

- When traversing =Let [(x1, e1), ..., (xn, en)] e=, for each variable
  =xi= decide whether it requires renaming by checking whether it is
  contained in =B=; for each of the names that are not in =B= the
  renaming is the name itself.  Generate these new names:
  #+begin_example
  x1 ~> x1', ..., xn ~> xn'
  #+end_example

- Rename the body =e= of =Let= using the environment =E= extended with
  the bindings =(x1, x1')=, ..., =(xn, xn')= and the set of names =B=
  extended with =x1=, ..., =xn=.  Rename, sequentially, =e1=, ...,
  =en= starting with the old environment =E= and the set of names
  produced by the renaming the body of =Let=.  (This particular order
  is arbitrary.)

- Ditto for =LetValues=.

What kind of monad do we need here?

It appears that =Expr= should be parametrized over the type of names
used to represent variables and then eventually =rename= should take
an expression of type =Expr Name= and return an expression of type
=Expr (Unique Name)=:
#+begin_src haskell
rename :: Expr Name -> Expr (Unique Name)
#+end_src
Then we need to turn =Expr (Unique Name)= into =Unique (Expr Name)=,
which suggests that =Expr= should be declared an instance of
=Traversable= (then the necessary commutation morphism is =sequence=
from =Traversable= class), which it almost certainly is.

Also, to carry the set of names known to be bound we can employ a
version of the state monad.
#+begin_src haskell
type Rename = State Names
type Names  = [Name]

rename' :: Expr Name -> [(Name, Unique Name)] -> Rename (Expr (Unique Name))
rename' (Var x) env = return (Var x')
    where
      x' = fromMaybe (return x) (lookup x env)
rename' (Let bindings body) = do
  used_names <- get
  let (xs, es) = unzip bindings
      maybeRename x | x `elem` used_names = uniqueName x
                    | otherwise = return x
      xs' = map maybeRename xs
  put (xs `union` used_names)
  body' <- rename' body (zip xs xs' ++ env)
  es' <- mapM (flip rename' env) es
  let bindings' = zip xs' es'
  return (Let bindings' body')
#+end_src

The idea that renaming turns =Expr Name= into =Expr (Unique Name)=
doesn't work, and in retrospect it is obvious why: when we transform
=Expr (Unique Name)= into =Unique (Expr Name)=, we chain the actions
of type =Unique Name=, and as a result things that must be named the
same are given different names.
