;;; -*- scheme -*-

(let ()

  (define (transforms-to-self! proc)
    (set-forward-transform! proc proc))

  (define (operates-on-primal! proc)
    (set-forward-transform!
     proc
     (lambda (b)
       (let* ((p (primal b))
	      (answer (proc p)))
	 (bundle answer (zero answer))))))

  (define (operates-on-primals! proc)
    (set-forward-transform!
     proc
     (lambda (b1 b2)
       (let* ((p1 (primal b1))
	      (p2 (primal b2))
	      (answer (proc p1 p2)))
	 (bundle answer (zero answer))))))

  (let* ((dummy (transforms-to-self! null?))
	 (dummy (transforms-to-self! boolean?))
	 (dummy (transforms-to-self! pair?))
	 (dummy (transforms-to-self! procedure?))

	 (dummy (operates-on-primal! zero?))
	 (dummy (operates-on-primal! positive?))
	 (dummy (operates-on-primal! negative?))
	 (dummy (operates-on-primal! real?))

	 (dummy (operates-on-primal! write))
	 (dummy (operates-on-primal! write-real))
	 (dummy (operates-on-primal! read-real))

	 (dummy
	  (set-forward-transform!
	   exp
	   (lambda (b)
	     (let ((p (primal b))
		   (t (tangent b)))
	       (bundle
		(exp p)
		(* (exp p) t))))))

	 (dummy
	  (set-forward-transform!
	   sin
	   (lambda (b)
	     (let ((p (primal b))
		   (t (tangent b)))
	       (bundle
		(sin p)
		(* (cos p) t))))))

	 (dummy
	  (set-forward-transform!
	   cos
	   (lambda (b)
	     (let ((p (primal b))
		   (t (tangent b)))
	       (bundle
		(cos p)
		(* (- 0 (sin p)) t))))))

	 (dummy
	  (set-forward-transform!
	   sqrt
	   (lambda (b)
	     (let ((p (primal b))
		   (t (tangent b)))
	       (bundle
		(sqrt p)
		(/ t (* 2 (sqrt p))))))))

	 (dummy
	  (set-forward-transform!
	   +
	   (lambda (x y)
	     (let ((px (primal x))
		   (tx (tangent x))
		   (py (primal y))
		   (ty (tangent y)))
	       (bundle
		(+ px py)
		(+ tx ty))))))

	 (dummy
	  (set-forward-transform!
	   -
	   (lambda (x y)
	     (let ((px (primal x))
		   (tx (tangent x))
		   (py (primal y))
		   (ty (tangent y)))
	       (bundle
		(- px py)
		(- tx ty))))))

	 (dummy
	  (set-forward-transform!
	   *
	   (lambda (x y)
	     (let ((px (primal x))
		   (tx (tangent x))
		   (py (primal y))
		   (ty (tangent y)))
	       (bundle
		(* px py)
		(+ (* py tx) (* px ty)))))))

	 (dummy
	  (set-forward-transform!
	   /
	   (lambda (x y)
	     (let ((px (primal x))
		   (tx (tangent x))
		   (py (primal y))
		   (ty (tangent y)))
	       (bundle
		(/ px py)
		(- (/ tx py) (/ (* px ty) (* py py))))))))

	 (dummy (operates-on-primals! <))
	 (dummy (operates-on-primals! <=))
	 (dummy (operates-on-primals! >))
	 (dummy (operates-on-primals! >=))
	 (dummy (operates-on-primals! =))

	 (dummy
	  (set-forward-transform!
	   if-procedure
	   (lambda (b1 c a)
	     (if (primal b1)
		 (c)
		 (a)))))

	 (dummy (transforms-to-self! bundle))
	 (dummy (transforms-to-self! primal))
	 (dummy (transforms-to-self! tangent))
	 (dummy (transforms-to-self! zero))
	 (dummy (transforms-to-self! forward?)))

    (let ()

      (define (perturb x) x)		; Compatibility with VLAD
      (define (unperturb x) x)		; Compatibility with VLAD
      (define (real x) x)		; Compatibility with VLAD

      (define (j* thing)
	(bundle thing (zero thing)))

      (define (derivative f)
	(lambda (x)
	  (tangent ((j* f) (bundle x 1)))))

      "HERE")))
