;;; -*- scheme -*-

(let ()

  (define (transforms-to-self! proc)
    (set-forward-transform! proc proc))

  (define (operates-on-primal! proc)
    (set-forward-transform!
     proc
     (lambda (b)
       (let* ((p (primal b))
	      (answer (proc p)))
	 (bundle answer (zero answer))))))

  (let ()
    (define dummy1 (transforms-to-self! null?))
    (define dummy2 (transforms-to-self! boolean?))
    (define dummy3 (transforms-to-self! pair?))

    (define dummy4 (operates-on-primal! zero?))
    (define dummy5 (operates-on-primal! positive?))
    (define dummy6 (operates-on-primal! negative?))
    (define dummy7 (operates-on-primal! null?))

    (define dummy8 (operates-on-primal! read-real))

    (let ()
      (define dummy1
	(set-forward-transform!
	 exp
	 (lambda (b)
	   (let ((p (primal b))
		 (t (tangent b)))
	     (bundle
	      (exp p)
	      (* (exp p) t))))))

      (define dummy2
	(set-forward-transform!
	 +
	 (lambda (x y)
	   (let ((px (primal x))
		 (tx (tangent x))
		 (py (primal y))
		 (ty (tangent y)))
	     (bundle
	      (+ px py)
	      (+ tx ty))))))

      (define dummy2a
	(set-forward-transform!
	 *
	 (lambda (x y)
	   (let ((px (primal x))
		 (tx (tangent x))
		 (py (primal y))
		 (ty (tangent y)))
	     (bundle
	      (* px py)
	      (+ (* py tx) (* px ty)))))))

      (define dummy3 (set-forward-transform! bundle bundle))
      (define dummy4 (set-forward-transform! primal primal))
      (define dummy5 (set-forward-transform! tangent tangent))
      (define dummy6 (set-forward-transform! zero zero))
      (define dummy7 (transforms-to-self! forward?))

      (let ()

	(define (perturb x) x)		; Compatibility with VLAD
	(define (unperturb x) x)	; Compatibility with VLAD
	(define (real x) x)		; Compatibility with VLAD

	(define (j* thing)
	  (bundle thing (zero thing)))

	(define (derivative f)
	  (lambda (x)
	    (tangent ((j* f) (bundle x 1)))))

	"HERE"))))
