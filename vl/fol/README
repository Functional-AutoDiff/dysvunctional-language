                      FOL (First-Order Language)
                             Alexey Radul

FOL is a simple-minded, typed, first-order language, which serves as
the compilation target for VL and DVL.  FOL has several design
objectives:
  FOL must be a convenient target for code generation after flow analysis
  FOL must be compilable to efficient machine code
  FOL should not be unduly illegible
In pursuit of these design objectives, FOL is a first-oder subset of
MIT Scheme, augmented with type declarations, supporting a limited
range of constructs.

The present code collection includes a FOL type checker, an in-memory
optimizing compiler from FOL to itself, and a runtime library for
executing FOL as MIT Scheme.  I have not yet experimented with
compiling FOL to any other target language.

The remainder of this document consists of three sections,
corresponding to the reasons why you might wish to peruse it:

Reading FOL If you just want to understand what the VL and DVL
compilers generate and what transformations are done to it.

Writing FOL If you want to know the constraints under which the VL and
DVL compilers operate and how they enable the services FOL provides.

Implementing FOL If you want to know how the FOL optimizer itself
works, and how to write analagous programs.


Reading FOL

FOL is a subset of Scheme, requiring minimal additional runtime
support.  You can run any FOL program right at your Scheme REPL:

(fol-eval <program>)
  Evaluates a FOL program in the ambient MIT Scheme.  This has the
  same effect as typing that data structure into the REPL (provided
  the FOL runtime support is loaded).

You can also read FOL as though it were Scheme.  The only things you
might not recognize are multiple value returns, type declarations, and
some of the primitives.

The multiple value returns are actually standard Scheme, augmented
with the LET-VALUES macro from SRFI 11.  What they do should be
obvious.  The type declarations serve to aid the FOL optimizer, and
while they can be used to type-check a FOL program, you can also just
ignore them.  In fact, the FOL runtime defines ARGUMENT-TYPES as a
macro that expands into nothing.  As to the primitives, FOL comes
with the following procedures predefined:

  CONS, CAR, CDR, VECTOR, VECTOR-REF, ABS, EXP, LOG, SIN, COS, TAN,
  ASIN, ACOS, SQRT, +, -, *, /, ATAN, EXPT, PAIR?, NULL?, REAL?, <,
  <=, >, >=, =, ZERO?, POSITIVE?, NEGATIVE?, READ-REAL, WRITE-REAL,
  REAL, GENSYM, GENSYM?, and GENSYM=.

Those with Scheme equivalents have the same semantics.  REAL is the
identity function, but instructs the compiler to treat its argument as
an unknown real number.  READ-REAL and WRITE-REAL do i/o; WRITE-REAL
returns the number written.  GENSYM synthesizes a fresh object that is
guaranteed to be distinct from all other objects.  GENSYM? tests
whether an object was created by GENSYM.  GENSYM= tests whether two
objects were created by the same dynamic call to GENSYM.

FOL is specified to be tail-recursive and memory-managed.  Order of
evaluation of procedure arguments is unspecified.  As of the present
writing, the compilation may fail to preserve the order (or even
presence!) of side-effects.  FOL is notionally strict, but the
compilation may rearrange the order of evaluation of various
subexpressions, even across procedure boundaries.  TODO is the dead
variable elimination good enough to make the same termination
guarantees that laziness does?


TODO Section Name

The FOL optimizer provides a number of services to the VL and DVL
compilers, in the form of post-optimizing their output so they don't
have to worry as much.  Specifically, the FOL optimizer aggressively
inlines procedures, aggressively replaces aggregates with
corresponding collections of scalars, and aggressively eliminates dead
and useless code.  The standard use case of COMPILE-TO-SCHEME emits
FOL with all these optimizations already performed, but you can also
get the output from the code generator, examine it, and optimize it
separately.

(compile-to-fol <vl-or-dvl>)
  Performs flow analysis on the given VL or DVL program (both VL and
  DVL define compile-to-fol routines) and generates unoptimized FOL
  that does the same job.

(check-program-types <program>)
  Verifies that the given FOL program is well typed.  If so, returns
  the type returned by the entry point; if not, signals an appropriate
  error.

(fol-optimize <program>)
  Completely optimizes the given FOL program and returns the result.

FOL Optimization proceeds as a cascade of stages, which you can also
run one by one to see their effect.  The stages are all
self-contained, except that most of them assume unique local variable
names; you should alpha-rename the program first, but then you can run
the remaining stages as much as you like, in any order.

(alpha-rename <program>)
  Renames variables in the given program so that no local variable
  binding binds the same name as any other, and returns the result.

(unique-names? <program>)
  Returns #t if all local variable names in the program are unique,
  and #f otherwise.

(alpha-rename? <program> <program>)
  Checks whether the two given programs are equal up to names of bound
  variables.

(inline <program>)
  Inlines as many procedures in the given FOL program as possible and
  returns the result.  Inlining might break alpha-renaming (by
  duplicating code bodies), so INLINE runs ALPHA-RENAME as a
  post-filter.

(approximate-anf <program>)
  Converts the given program into approximate A-normal form, where all
  procedure calls operate on variables or constants, and returns the
  result.  This is used for scalar replacement of aggregates, below.

(approximate-anf? <program>)
  Returns #t if the given program is already in approximate A-normal
  form, and #f otherwise.

(scalar-replace-aggregates <program>)
  Performs scalar replacement of aggregates and returns the resulting
  program.  All possible data structure allocations (namely, instances
  of CONS and VECTOR) are replaced by appropriate use of VALUES and
  LET-VALUES.  This is the stage that first introduces them.  If the
  input program is union-free, this will eliminate all consing except
  for the construction of the final answer that is returned from the
  entry point, should that be a structure.

  The SRA algorithm requires its input to be in approximate A-normal
  form, so SCALAR-REPLACE-AGGREGATES preprocesses its input program
  into it with APPROXIMATE-ANF.

(intraprocedural-de-alias <program>)
  Eliminates aliases inside procedure bodies and returns the result.
  An alias is a variable binding of the form (let ((x y)) ...); x
  becomes replaced by y in the body of this binding.  This step is
  very important because between them a-normal form conversion and
  scalar replacement of aggregates end up generating lots of aliases.
  As suggested by its name, this does not do full interprocedural
  must-alias analysis, and does not detect circumstances where some
  formal parameters to some procedure are reliably always given the
  same value.

(eliminate-intraprocedural-dead-variables <program>)
  Eliminates dead code inside procedure bodies and returns the result.
  As suggested by the name, this does not detect circumstances where
  some variable is passed around from one user-defined procedure to
  another but then never used.

(tidy <program>)
  Performs other optimizations that do not have dedicated stages and
  returns the result.  The most important of them for legibility is to
  inline the definitions of variables that are used only once.

In addition to the optimizer and its individual stages, FOL also
provides some legibility aids.  On one side, there is a utility to
remove the argument type declarations if desired.  The result will no
longer type check (obviously), and will cease to be acceptable as
input to several of the optimization stages, but will still execute in
MIT Scheme, and may be easier to read.

(strip-argument-types <program>)
  Removes the argument type declarations from a FOL program and
  returns the result (which can no longer be properly called a FOL
  program).

As a legibility aid on the opposite end of the spectrum, you can also
ask VL or DVL to generate FOL with a stronger type system.  Instead of
using Scheme vectors for everything, this variant of FOL uses Scheme
record types (introduced with DEFINE-STRUCTURE), which may improve
legibility.

(analyze-and-generate <vl-or-dvl>)
  Performs flow analysis on the given VL or DVL program (both VL and
  DVL define analyze-and-generate routines) and generates FOL with
  DEFINE-STRUCTURE forms that does the same job.

The optimizer does not understand DEFINE-STRUCTURE, so you have to get
rid of them before invoking any of the stages.

(structure-definitions->vectors <program>)
  Replaces Scheme record types with Scheme vectors in a FOL program
  and returns the result.  Said result has no DEFINE-STRUCTURE forms,
  and is suitable for optimization.

The simpler-to-use COMPILE-TO-FOL could be defined as
ANALYZE-AND-GENERATE followed by STRUCTURE-DEFINITIONS->VECTORS.


Writing FOL

A FOL program is a Scheme data structure.  This may have been parsed
from a file or constructed directly in memory, as appropriate for the
application.

FOL follows the following grammar:

program    = <expression>
           | (begin <definition> ... <expression>)

definition = (define (<proc-var> <data-var> ...)
               (argument-types <shape> ...)
               <expression>)

shape      = real | bool | gensym | ()
           | (cons <shape> <shape>) | (vector <shape> ...) | (values <shape> ...)

expression = <data-var>
           | <number> | <boolean> | ()
           | (if <expression> <expression> <expression>)
           | (let ((<data-var> <expression>) ...) <expression>)
           | (let-values (((<data-var> <data-var> <data-var> ...) <expression>))
               <expression>)
           | <access>
           | <construction>
           | (values <expression> <expression> <expression> ...)
           | (<proc-var> <expression> ...)

access = (car <expression>)
       | (cdr <expression>)
       | (vector-ref <expression> <integer>)

construction = (cons <expression> <expression>)
             | (vector <expression> ...)

FOL distinguishes two types of variables, one for holding procedures
and one for holding data; both are represented as Scheme symbols.  The
procedure variables have global scope, must be globally unique, and
may only be bound by DEFINE forms.  The data variables are lexically
scoped with shadowing, and may be bound by LET forms and the formal
parameter positions of DEFINE forms.  Procedures may only be defined
at the top level.  Applications may only apply procedures directly by
name.  This serves to make FOL a first-order language.

FOL being first-order was the point.  The purpose of hairy flow
analysis is to transform a computation concisely expressed in a
higher-order language, in this case with AD operators, into an
equivalent computation in a first-order language.  The job of the FOL
optimizer is to give the flow analysis freedom to generate an
arbitrarily ugly FOL program; on the other hand the FOL optimizer can
use the restrictions on FOL, notably its first-order nature, to
optimize it using standard, well-understood techniques.

FOL procedure definitions must be annotated with the types of the
arguments expected and the type of the result.  The annotation is
achieved via the ARGUMENT-TYPES form in the grammar.  The shapes given
in the form are taken to be parallel to the formal parameters, except
that the last one refers to the type returned by the procedure.  The
type declarations are used to perform scalar replacement of
aggregates, and also serve as a useful sanity check when debugging the
FOL optimizer or the code generator that gives it input.

The FOL type system does not at present admit user-specified types,
union types, or recursive types.  This will be changed when FOL is
extended to accept the results of compiliing non-union-free VL or DVL
programs.

FOL supports multiple value returns from procedures and expressions
via the standard Scheme VALUES construct, and multiple value binding
via the SRFI-11 LET-VALUES construct.  All VALUES expressions must be
in tail position with respect to a matching LET-VALUES expression.
You will note that because multiple value returns via the VALUES
construct cannot be stored in data structures or bound as variables
without destructuring them, they do not need to be represented in the
runtime as heap-allocated objects, but can instead be implemented by
just placing the values to be returned on the stack.  The VL and DVL
code generator does not emit VALUES or LET-VALUES expressions; FOL
supports them as targets for the scalar replacement of aggregates
optimization.

For implementation convenience, LET-VALUES is restricted to binding
from a single expression; no parallel form is provided.  Also, nullary
and unary multiple value returns are not permitted in FOL because they
are easy to get rid of and would not interact as well as one would
like with MIT Scheme's expression return semantics.

FOL reserves the tokens that appear in the grammar as names to which
procedures and formal parameters may not be bound.  The set of FOL
reserved words is:

  BEGIN, DEFINE, IF, LET, LET-VALUES, VALUES, CONS, CAR, CDR, VECTOR,
  and VECTOR-REF.

These all behave as in Scheme.  In addition, FOL predefines the
following procedures:

  ABS, EXP, LOG, SIN, COS, TAN, ASIN, ACOS, SQRT, +, -, *, /, ATAN,
  EXPT, PAIR?, NULL?, REAL?, <, <=, >, >=, =, ZERO?, POSITIVE?,
  NEGATIVE?, READ-REAL, WRITE-REAL, REAL, GENSYM, GENSYM?, and
  GENSYM=.

TODO Do I really need to duplicate these two paragraphs here?

Those with Scheme equivalents have the same semantics.  REAL is the
identity function, but instructs the compiler to treat its argument as
an unknown real number.  READ-REAL and WRITE-REAL do i/o; WRITE-REAL
returns the number written.  GENSYM synthesizes a fresh object that is
guaranteed to be distinct from all other objects.  GENSYM? tests
whether an object was created by GENSYM.  GENSYM= tests whether two
objects were created by the same dynamic call to GENSYM.

FOL is specified to be tail-recursive and memory-managed.  Order of
evaluation of procedure arguments is unspecified.  As of the present
writing, the compilation may fail to preserve the order (or even
presence!) of side-effects.  FOL is notionally strict, but the
compilation may rearrange the order of evaluation of various
subexpressions, even across procedure boundaries.  TODO is the dead
variable elimination good enough to make the same termination
guarantees that laziness does?

TODO Discuss define-structure forms


Implementing FOL

The implementation of FOL is, of course, the matter at hand in the
rest of this program.  Here is the table of contents:

optimize.scm        Toplevel; architecture overview
type-check.scm      Type checker
structs.scm         structure-definitions->vectors
inline.scm          Inliner
  feedback-vertex-set.scm  Graph algorithm supporting inlining
alpha-remaing.scm   Uniquifying bound names
a-normal-form.scm   A-normal form converter
sra.scm             Scalar replacement of aggregates
de-alias.scm        Alias elimination
dead-code.scm       Dead variable elimination
syntax.scm          Low-level support; FOL syntax
srfi-11.scm         Reference implementation of SRFI 11

The FOL compiler makes extensive use of a pattern matching and
replacement system.  TODO Explain enough of it.


Future of FOL

There are two glaring gaps in the extant FOL system.  One is that it
does not accept non-union-free programs.  At this moment this is OK
because neither VL nor DVL compile non-union-free programs either, but
in time this defect will need to be corrected.  Doing so will involve
a reworking of the FOL type system and an updating of the SRA
algorithm, but should not require any other major changes.

The other glaring defect is the absence of a really fast execution
engine for FOL.  Obvious candidates include compiling FOL to machine
code or C with the MIT Scheme compiler, or direct custom translation
to C (or C--) for further processing with, e.g., gcc.  The latter
activity may not be a trivial variation on the former, because in so
doing the semantics of FOL may perhaps be fruitfully made somewhat
different from Scheme semantics, particularly with respect to the
numeric tower.  This process will be undertaken as VL, DVL, and FOL
scale to examples that are too slow to interpret.

Finally, the current state of FOL is also open to some improvements
that don't affect its interface, namely implementing interprocedural
must alias analysis and dead code elimination, and better
understanding the nature of what the rule-based tidier does to
implement it directly in algorithms (as that stands to improve its
asymptotic complexity).
