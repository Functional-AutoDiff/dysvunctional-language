                      FOL (First-Order Language)
                             Alexey Radul

FOL is a simple-minded first-order language, which serves as the
compilation target for VL and DVL.  FOL has several design
objectives:
  FOL must be a convenient target for code generation after flow analysis
  FOL must be compilable to efficient machine code
  FOL should not be unduly illegible
In pursuit of these design objectives, FOL is a first-oder subset
of MIT Scheme, supporting a limited range of constructs.

The present code collection includes an in-memory optimizing compiler
from FOL to itself and a runtime library for executing FOL as MIT
Scheme.  I have not yet experimented with compiling FOL to any other
target language.

There are two reasons why you might wish to read this document.  One
is that you are trying to understand VL or DVL, and want to know what
they generate and what post-processing is done to their output in
broad terms.  For this purpose, the remainder of this README should
suffice.  The other is that you may want to understand FOL compilation
in detail, and perhaps study an example of the standard first-order
compilation techniques that the FOL optimizer uses.  In that case, you
should read this README first, and then peruse the remainder of the
source, which contains extensive internal explanation.

A FOL program is a Scheme data structure.  This may have been parsed
from a file or constructed directly in memory, as appropriate for the
application.

FOL follows the following grammar:

program    = <expression>
           | (begin <definition> ... <expression>)

definition = (define (<proc-var> <data-var> ...) <expression>)

expression = <data-var>
           | <number> | <boolean> | ()
           | (<proc-var> <expression> ...)
           | (if <expression> <expression> <expression>)
           | (let ((<data-var> <expression>) ...) <expression>)
           | (let-values (((<data-var> <data-var> <data-var> ...) <expression>))
               <expression>)
           | (values <expression> <expression> <expression> ...)

FOL distinguishes two types of variables, one for holding procedures
and one for holding data; both are represented as Scheme symbols.  The
procedure variables have global scope, must be globally unique, and
may only be bound by DEFINE forms.  The data variables are lexically
scoped with shadowing, and may be bound by LET forms and the formal
parameter positions of DEFINE forms.

You may note in the above grammar several restrictions, as compared to
Scheme.  Procedures may only be defined at the top level.  Procedure
names must be unique.  Applications may only apply procedures directly
by name --- procedures are second-class in FOL.  These restrictions
are consistent with being the target language for post-flow-analysis
code generation, and make FOL considerably easier to compile to
efficient code.

FOL supports multiple value returns from procedures and expressions
via the standard Scheme VALUES construct, and multiple value binding
via the SRFI-11 LET-VALUES construct.  The latter is restricted to
binding from a single expression; no parallel form is provided.  All
VALUES expressions must be at least binary and must be in tail
position with respect to a matching LET-VALUES expression.  You will
note that because multiple value returns via the VALUES construct
cannot be stored in data structures or bound as variables without
destructuring them, they do not need to be represented in the runtime
as heap-allocated objects, but can instead be implemented by just
placing the values to be returned on the stack.  The VL and DVL code
generator does not emit VALUES or LET-VALUES expressions; FOL supports
them as targets for the scalar replacement of aggregates optimization.

FOL comes with the following procedures predefined:

  CONS, CAR, CDR, VECTOR, VECTOR-REF, ABS, EXP, LOG, SIN, COS, TAN,
  ASIN, ACOS, SQRT, +, -, *, /, ATAN, EXPT, PAIR?, NULL?, REAL?, <,
  <=, >, >=, =, ZERO?, POSITIVE?, NEGATIVE?, READ-REAL, WRITE-REAL,
  REAL, GENSYM, GENSYM?, and GENSYM=.

Those with Scheme equivalents have the same semantics.  REAL is the
identity function, but instructs the compiler to treat its argument as
an unknown real number.  READ-REAL and WRITE-REAL do i/o; WRITE-REAL
returns the number written.  GENSYM synthesizes a fresh object that is
guaranteed to be distinct from all other objects.  GENSYM? tests
whether an object was created by GENSYM.  GENSYM= tests whether two
objects were created by the same dynamic call to GENSYM.

FOL is specified to be tail-recursive and memory-managed.  Order of
evaluation of procedure arguments is unspecified.  As of the present
writing, the compilation may fail to preserve the order (or even
presence!) of side-effects.  FOL is notionally strict, but the
compilation may rearrange the order of evaluation of various
subexpressions, even across procedure boundaries.  TODO is the dead
variable elimination good enough to make the same termination
guarantees that laziness does?

TODO Discuss FOL type declarations.

I also provide a FOL->FOL optimizing compiler called
PRETTIFY-COMPILER-OUTPUT.  This has three main pieces, each of
which can also be applied separately from the others: aggressive
procedure inlining, aggressive replacement of aggregates with
scalars, and elimination of unused or once-used variables.
Details elsewhere.


Obvious candidate target languages for further FOL compilation include
machine code or C with the MIT Scheme compiler, or direct custom
translation to C (or C--) for further processing with, e.g., gcc.  The
latter activity may not be a trivial variation on the former, because
in so doing the semantics of FOL may perhaps be fruitfully made
somewhat different from Scheme semantics, particularly with respect to
the numeric tower.
