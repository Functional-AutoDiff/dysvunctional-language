                      FOL (First-Order Language)
                             Alexey Radul

FOL is a simple-minded, typed, first-order language, which serves as
the compilation target for VL and DVL.  FOL has several design
objectives:
  FOL must be a convenient target for code generation after flow analysis
  FOL must be compilable to efficient machine code
  FOL should not be unduly illegible
In pursuit of these design objectives, FOL is a first-oder subset of
MIT Scheme, augmented with type declarations, supporting a limited
range of constructs.

The present code collection includes a FOL type checker, an in-memory
optimizing compiler from FOL to itself, and a runtime library for
executing FOL as MIT Scheme.  I have not yet experimented with
compiling FOL to any other target language.

There are two reasons why you might wish to read this document.  One
is that you are trying to understand VL or DVL, and want to know what
they generate and what post-processing is done to their output in
broad terms.  For this purpose, the remainder of this README should
suffice.  The other is that you may want to understand FOL compilation
in detail, and perhaps study an example of the standard first-order
compilation techniques that the FOL optimizer uses.  In that case, you
should read this README first, and then peruse the remainder of the
source, which contains extensive internal explanation.

Description of FOL

A FOL program is a Scheme data structure.  This may have been parsed
from a file or constructed directly in memory, as appropriate for the
application.

FOL follows the following grammar:

program    = <expression>
           | (begin <definition> ... <expression>)

definition = (define (<proc-var> <data-var> ...)
               (argument-types <shape> ...)
               <expression>)

shape      = real | bool | gensym | ()
           | (cons <shape> <shape>) | (vector <shape> ...) | (values <shape> ...)

expression = <data-var>
           | <number> | <boolean> | ()
           | (<proc-var> <expression> ...)
           | (if <expression> <expression> <expression>)
           | (let ((<data-var> <expression>) ...) <expression>)
           | (let-values (((<data-var> <data-var> <data-var> ...) <expression>))
               <expression>)
           | (values <expression> <expression> <expression> ...)

FOL procedure definitions must be annotated with the types of the
arguments expected and the type of the result.  The annotation is
achieved via the ARGUMENT-TYPES form in the grammar.  The shapes given
in the form are taken to be parallel to the formal parameters, except
that the last one refers to the type returned by the procedure.

The FOL type system does not at present admit user-specified types,
union types, or recursive types.  This will be changed when FOL is
extended to accept the results of compiliing non-union-free VL or DVL
programs.

FOL distinguishes two types of variables, one for holding procedures
and one for holding data; both are represented as Scheme symbols.  The
procedure variables have global scope, must be globally unique, and
may only be bound by DEFINE forms.  The data variables are lexically
scoped with shadowing, and may be bound by LET forms and the formal
parameter positions of DEFINE forms.

You may note in the above grammar several restrictions, as compared to
Scheme.  Procedures may only be defined at the top level.  Procedure
names must be unique.  Applications may only apply procedures directly
by name --- procedures are second-class in FOL.  These restrictions
are consistent with being the target language for post-flow-analysis
code generation, and make FOL considerably easier to compile to
efficient code.

FOL supports multiple value returns from procedures and expressions
via the standard Scheme VALUES construct, and multiple value binding
via the SRFI-11 LET-VALUES construct.  The latter is restricted to
binding from a single expression; no parallel form is provided.  All
VALUES expressions must be at least binary and must be in tail
position with respect to a matching LET-VALUES expression.  You will
note that because multiple value returns via the VALUES construct
cannot be stored in data structures or bound as variables without
destructuring them, they do not need to be represented in the runtime
as heap-allocated objects, but can instead be implemented by just
placing the values to be returned on the stack.  The VL and DVL code
generator does not emit VALUES or LET-VALUES expressions; FOL supports
them as targets for the scalar replacement of aggregates optimization.

FOL comes with the following procedures predefined:

  CONS, CAR, CDR, VECTOR, VECTOR-REF, ABS, EXP, LOG, SIN, COS, TAN,
  ASIN, ACOS, SQRT, +, -, *, /, ATAN, EXPT, PAIR?, NULL?, REAL?, <,
  <=, >, >=, =, ZERO?, POSITIVE?, NEGATIVE?, READ-REAL, WRITE-REAL,
  REAL, GENSYM, GENSYM?, and GENSYM=.

Those with Scheme equivalents have the same semantics.  REAL is the
identity function, but instructs the compiler to treat its argument as
an unknown real number.  READ-REAL and WRITE-REAL do i/o; WRITE-REAL
returns the number written.  GENSYM synthesizes a fresh object that is
guaranteed to be distinct from all other objects.  GENSYM? tests
whether an object was created by GENSYM.  GENSYM= tests whether two
objects were created by the same dynamic call to GENSYM.

FOL is specified to be tail-recursive and memory-managed.  Order of
evaluation of procedure arguments is unspecified.  As of the present
writing, the compilation may fail to preserve the order (or even
presence!) of side-effects.  FOL is notionally strict, but the
compilation may rearrange the order of evaluation of various
subexpressions, even across procedure boundaries.  TODO is the dead
variable elimination good enough to make the same termination
guarantees that laziness does?

TODO Discuss define-structure forms

Using FOL

The standard use case of the VL and DVL compilers already invokes the
FOL optimizer as a post-filter, and therefore emits fully optimized
FOL.  There is at that point nothing more to do but read it or run it.

(fol-eval <program>)
  Evaluates a FOL program in the ambient MIT Scheme.  This has the
  same effect as typing that data structure into the REPL (provided
  the FOL runtime support is loaded).

You can also watch the process happen, and otherwise manipulate
the intermediate stages.

(analyze-and-generate <vl-or-dvl>)
  Performs flow analysis on the given VL or DVL program (both VL and
  DVL define analyze-and-generate routines) and generates unoptimized
  FOL that does the same job.

(check-program-types <program>)
  Verifies that the given FOL program is well typed.  If so, returns
  the type returned by the entry point; if not, signals an appropriate
  error.

(fol-optimize <program>)
  Completely optimizes the given FOL program and returns the result.
  Optimization proceeds as a cascade of stages, each of which
  is also available separately:

(structure-definitions->vectors <program>)
  Inlines and removes all DEFINE-STRUCTURE forms from the given FOL
  program and returns the resulting FOL program.

(inline <program>)
  Inlines as many procedures in the given FOL program as possible and
  returns the result.

(full-alpha-rename <program>)
  Alpha-renames the given program, so that no local variable binding
  shadows any other and returns the result.

  TODO FULL-ALPHA-RENAME errs if its input has any LET-VALUES or VALUES.

(sra-anf <program>)
  Converts the given program into (approximately) A-normal form, where
  all procedure calls operate on variables or constants and returns
  the result.  This is necessary for scalar replacement of aggregates,
  below.

  TODO SRA-ANF barfs if its input has any LET-VALUES or VALUES.

(sra-program <program>)
  Performs scalar replacement of aggregates and returns the resulting
  program.  All possible data structure allocations (namely, instances
  of CONS and VECTOR) are replaced by appropriate use of VALUES and
  LET-VALUES.  This is the stage that first introduces them.  If the
  input program is union-free, this will eliminate all consing except
  for the construction of the final answer that is returned from the
  entry point, should that be a structure.

  SRA-PROGRAM expects its input to be in (approximate) A-normal form,
  and preserves this feature.

  TODO SRA-PROGRAM barfs if its input has any LET-VALUES or VALUES.

(intraprocedural-de-alias <program>)
  Eliminates aliases inside procedure bodies and returns the result.
  An alias is a variable binding of the form (let ((x y)) ...); x
  becomes replaced by y in the body of this binding.  This step is
  very important because between them SRA-ANF and SRA-PROGRAM end up
  generating lots of aliases.  As suggested by its name, this does not
  do full interprocedural must-alias analysis, and does not detect
  circumstances where some formal parameters to some procedure are
  reliably always given the same value.  Preserves A-normal form.

(intraprocedural-dead-variable-elimination <program>)
  Eliminates dead code inside procedure bodies and returns the result.
  Preserves A-normal form.

(tidy <program>)
  Performs other optimizations that do not have dedicated stages and
  returns the result.  The most important for legibility thing this
  step does is inline the definitions of variables that are used only
  once.  This undoes some of the work of the A-normal form conversion,
  but leads to much more legible output.

In addition to the optimizer and its individual stages, FOL also
provides a utility to remove the argument type declarations if
desired.  The result will no longer type check (obviously), and will
cease to be acceptable as input to several of the optimization stages,
but will still execute, and may be easier to read.

(strip-argument-types <program>)
  Removes the argument type declarations from a FOL program and
  returns the result (which can no longer be properly called a FOL
  program).



Obvious candidate target languages for further FOL compilation include
machine code or C with the MIT Scheme compiler, or direct custom
translation to C (or C--) for further processing with, e.g., gcc.  The
latter activity may not be a trivial variation on the former, because
in so doing the semantics of FOL may perhaps be fruitfully made
somewhat different from Scheme semantics, particularly with respect to
the numeric tower.
