(declare (usual-integrations))
;;;; (Approximate) A-normal form conversion

(define (push-access expr1 expr2)
  `(,(car expr1) ,expr2 ,@(cddr expr1)))

(define (sra-anf expr)
  (define (rename-nontrivial-expression expr win)
    (cond ((symbol? expr) (win expr '()))
          ((number? expr) (win expr '()))
;;           ((accessor? expr)
;;            (rename-nontrivial-subexpressions
;;             (cadr expr)
;;             (lambda (result names)
;;               (win (push-access expr result) names))))
;;           ((construction? expr)
;;            (rename-nontrivial-expressions
;;             (cdr expr)
;;             (lambda (results names)
;;               (win (cons (car expr) results) names))))
          (else
           (let ((name (make-name 'anf)))
             (win name `((,name ,expr)))))))
  (define (rename-nontrivial-expressions exprs win)
    (if (null? exprs)
        (win '() '())
        (rename-nontrivial-expression
         (car exprs)
         (lambda (result names)
           (rename-nontrivial-expressions (cdr exprs)
            (lambda (results more-names)
              (win (cons result results)
                   (append names more-names))))))))
  (let loop ((expr expr))
    (cond ((symbol? expr) expr)
          ((number? expr) expr)
          ((boolean? expr) expr)
          ((null? expr) expr)
          ((if-form? expr)
           `(if ,(loop (cadr expr))
                ,(loop (caddr expr))
                ,(loop (cadddr expr))))
          ((let-form? expr)
           `(let ,(map (lambda (binding)
                         `(,(car binding) ,(loop (cadr binding))))
                       (cadr expr))
              ,(loop (caddr expr))))
          ((let-values-form? expr)
           ((rule `(let-values (((? names) (? exp)))
                     (? body))
                  `(let-values ((,names ,(loop exp)))
                     ,(loop body)))
            expr))
          ((begin-form? expr)
           (map loop expr))
          ((definition? expr)
           ((rule `(define (? formals)
                     (argument-types (?? stuff))
                     (? body))
                  `(define ,formals
                     (argument-types ,@stuff)
                     ,(loop body)))
            expr))
          (else ; application or multiple value return
           (rename-nontrivial-expressions
            expr
            (lambda (results names)
              (if (not (null? names))
                  (loop `(let ,names ,results))
                  expr)))))))
