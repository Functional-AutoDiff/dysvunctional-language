Expository explanations
- Push TIDY into its own file?
- Make the assertions in the README true
- Actually explain SRA
- Garbage collect syntax.scm
- Update explanation of VL (and DVL?) to reflect FOL's separate
  identity
- Make FOL executable standalone, releasable, workbookable


TODO: SRA is not idempotent (and does not preserve ANF) because of the
reconstruction code
- The postfix of the optimizer after ANF (inclusive) should be
  idempotent in spite of the reconstruction code.
  - only not, see note below

NB: literal booleans should only appear when a shape is being shipped
to the outside world
NB: various stages expect/emit alpha-renamed and/or anf'd code
NB: The reason that some of my recursions are broken into expression
  loops and a toplevel crunch is that the top level is the only
  place that introduces bindings with letrec scope.
NB: All the arithmetic reduction rules make work for de-aliasing
  because of (let ((x (+ 0 y))) ...)
NB: (* 0 x) -> 0 makes work for dead code elimination because x may
  have contained the last reference to something
NB: inline may introduce shadowing

Define and test asserted invariants such as being in ANF or being
alpha renamed?  "Prove" that various stages (e.g. SRA) always preserve
them?
- Use the grammars to construct programs that generate random
  structures obeying those grammars?
- Being in ANF might be defined as "the ANF transform does nothing"
- Ditto being alpha renamed

There is a diagram: Each box is a set of properties that a FOL program
might satisfy, and each arrow defines the applicability of a
transformation.  I want this diagram to have as few boxes as possible;
I want all loops in this diagram to be idempotent (up to equality?
alpha renaming?).  Current states are:
- FOL + define-structure without multivalue returns
- FOL without multivalue returns
- FOL without shadowing or multivalue returns
- FOL in ANF without shadowing or multivalue returns
- FOL in ANF without shadowing
- FOL without shadowing
- FOL without shadowing or type declarations
with obvious inclusions by identity.
Can I also talk about which stages enable which others, or generate
work for them, or don't, in the sense of de-aliasing and dead code
elimination being (I think) orthogonal?

----------------------------------------------------------------------

Good output on dvl-sqrt-5
- MIT Scheme doesn't like multiple underscores in the same binding clause

Fast enough to put dvl-sqrt-5 into the test suite?

autogenerating symbol names leaks memory


Write inlining of used-once bindings (post-SRA); undoes ANF
- This is the intraprocedural analog of inlining procedures (I think)

Rename vector to closure, to distinguish it from (variable-length)
arrays (that may be accessed at computed indecies).

(begin
 (define (foo x y)
   (argument-types real real real)
   (+ x y))
 (let ((foo 3))
   (foo 1 2)))
breaks horribly (on inlining, I think)
