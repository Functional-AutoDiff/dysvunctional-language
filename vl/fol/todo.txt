Expository explanations
- Push TIDY into its own file?
- Make the assertions in the README true
- Actually explain SRA
- Garbage collect syntax.scm
- Update explanation of VL (and DVL?) to reflect FOL's separate
  identity
- Make FOL executable standalone, releasable, workbookable

SRA can remove call graph edges by eliminating contentless expressions
that contain calls to procedures.  However, all procedures are
contentful, because otherwise the code generator would not have
emitted them.  Does the code generator emit expressions that request
some content and then throw it away?  In any case, there are FOL
programs where SRA exposes work for inlining; should I explain this?
Should I explain that VL and DVL do not emit such programs?

TODO: SRA is not idempotent (and does not preserve ANF) because of the
reconstruction code
- The postfix of the optimizer after ANF (inclusive) should be
  idempotent in spite of the reconstruction code.
  - only not, see note below

NB: The reason that some of my recursions are broken into expression
  loops and a toplevel crunch is that the top level is the only
  place that introduces bindings with letrec scope.
NB: All the arithmetic reduction rules make work for de-aliasing
  because of (let ((x (+ 0 y))) ...)
NB: (* 0 x) -> 0 makes work for dead code elimination because x may
  have contained the last reference to something
NB: inline may introduce shadowing
NB: dead code elimination may permit more inlining
NB: inlining is not actually idempotent

Define and test asserted invariants such as being in ANF or being
alpha renamed?  "Prove" that various stages (e.g. SRA) always preserve
them?
- Use the grammars to construct programs that generate random
  structures obeying those grammars?
- Being in ANF might be defined as "the ANF transform does nothing"
- Ditto being alpha renamed

There is a diagram: Each box is a set of properties that a FOL program
might satisfy, and each arrow defines the applicability of a
transformation.  I want this diagram to have as few boxes as possible;
I want all loops in this diagram to be idempotent (up to equality?
alpha renaming?).  Current states are:
- FOL + define-structure without multivalue returns
- FOL without multivalue returns
- FOL without shadowing or multivalue returns
- FOL in ANF without shadowing or multivalue returns
- FOL in ANF without shadowing
- FOL without shadowing
- FOL without shadowing or type declarations
with obvious inclusions by identity.
Can I also talk about which stages enable which others, or generate
work for them, or don't, in the sense of de-aliasing and dead code
elimination being (I think) orthogonal?

----------------------------------------------------------------------

Good output on dvl-sqrt-5
- MIT Scheme doesn't like multiple underscores in the same binding clause

Fast enough to put dvl-sqrt-5 into the test suite?

autogenerating symbol names leaks memory


Write inlining of used-once bindings (post-SRA); undoes ANF
- This is the intraprocedural analog of inlining procedures (I think)

Rename vector to closure, to distinguish it from (variable-length)
arrays (that may be accessed at computed indecies).

(begin
 (define (foo x y)
   (argument-types real real real)
   (+ x y))
 (let ((foo 3))
   (foo 1 2)))
breaks horribly on inlining

INLINE breaks alpha renaming by duplicating code bodies.

SRA depends on alpha renaming because it deparallelizes LET-VALUES (in
its post-processor).

de-aliasing depends on alpha renaming when checking whether a variable
is aliased to something in scope at its binding site (this may be
fixable).

TIDY depends on alpha renaming because it lifts LETs.
