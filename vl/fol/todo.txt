Compilation with MIT Scheme
- Interprocedural must-alias analysis?
- Interprocedural dead variable elimination?
- Analysis-time dead variable elimination??
- Solved gensyms?  Is this actually possible?

Compilation with MIT Scheme and floating-only numerics?

----------------------------------------------------------------------

Expository explanations
- Push TIDY into its own file?
- Explain the rule system
- Sweep TODOs
- Make the assertions in the README true
- Actually explain SRA
- Garbage collect syntax.scm
- Update explanation of VL (and DVL?) to reflect FOL's separate
  identity
- Make FOL executable standalone, releasable, workbookable

NB: SRA can remove call graph edges by eliminating contentless
  expressions that contain calls to procedures.  However, all
  procedures are contentful, because otherwise the code generator
  would not have emitted them.  Does the code generator emit
  expressions that request some content and then throw it away?  In
  any case, there are FOL programs where SRA exposes work for
  inlining; should I explain this?  Should I explain that VL and DVL
  do not emit such programs?

NB: The reason that some of my recursions are broken into expression
  loops and a toplevel crunch is that the top level is the only
  place that introduces bindings with letrec scope.

----------------------------------------------------------------------

The next step both for good output and fast compilation is:

Try to break gensym handling
- Try to make solved gensyms actually solved
  - Good output on dvl-sqrt-5
  - Fast enough to put dvl-sqrt-5 into the test suite?

Write inlining of used-once bindings (post-SRA); undoes ANF
- This is the intraprocedural analog of inlining procedures (I think)


Sussman's example of where differentiating functions that output
functions is useful:

(define (((delta eta) f) q)
  (let ((g (lambda (eps) (f (+ q (* eps eta))))))
    ((D g) 0)))

; Nonsense useage example:
((((delta cos) D) square) 3)

Generate syntax checkers from the grammars?  Generate random example
programs from the grammars?

Software-validate the following assertions:
- all optimizer stages preserve uniqueness of names
- all optimizer stages preserve the semantics of any valid FOL program
  (with alpha renaming inserted where needed)
  - what is the exact list of criteria for "valid"?
    - can I effectively check those with the type checker?
      - can I efficiently generate random valid programs?
- de-aliasing, dead code elimination, and tidying are idempotent
- de-aliasing does not generate work for inlining and SRA
- dead variable elimination does not generate work for SRA or de-aliasing

Rename vector to closure, to distinguish it from (variable-length)
arrays (that may be accessed at computed indecies).

(begin
 (define (foo x y)
   (argument-types real real real)
   (+ x y))
 (let ((foo 3))
   (foo 1 2)))
breaks horribly on inlining (global vs local name clash)

INLINE breaks alpha renaming by duplicating code bodies.

SRA depends on alpha renaming because it deparallelizes LET-VALUES (in
its post-processor).

de-aliasing depends on alpha renaming when checking whether a variable
is aliased to something in scope at its binding site (this may be
fixable).

TIDY depends on alpha renaming because it lifts LETs.
